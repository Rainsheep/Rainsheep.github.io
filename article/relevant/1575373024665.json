{"relevantArticles":[{"articleTitle":"Emmet常用语法","articleAbstractText":"官方文档：https://docs.emmet.io/cheat-sheet  HTML 初始结构(!) 先输入！然后按 tab 生成基础结构  id(#)和 class(.)  div#test &lt;div id=\"test\"&gt;&lt;/div&gt; div.test &lt;div class=\"test\"&gt;&lt;/div&gt; form#search.wide &lt;form id=\"search\" class=\"wide\"&gt;&lt;/form&gt; p.class1.class2.class3 &lt;p class=\"class1 class2 class3\"&gt;&lt;/p&gt;  子节点(&gt;)，兄弟结点(+)，上级节点(^)  div&gt;ul&gt;li&gt;p  &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;   div+ul+p  &lt;div&gt;&lt;/div&gt; &lt;....","articleStatus":0,"articlePermalink":"/articles/2020/01/01/1577858373027.html","articleImg1URL":"https://img.hacpai.com/file/2020/01/p20200101013412-55772897.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"},{"articleTitle":"Java中List, Integer[], int[]的相互转换","articleAbstractText":"有时候 list和数组 int[]转换很麻烦。 List和 String[]也同理。难道每次非得写一个循环遍历吗？其实一步就可以搞定。 本文涉及到一些 Java8 的特性。如果没有接触过就先学会怎么用，然后再细细研究。 package package1; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; import java.util.stream.Stream; public class Main { public static void main(String[] args) { int[] arr = {1, 2, 3, 4, 5}; // int[] 转 List&lt;Integer&gt;  List&lt;Integer&gt; list1 = Arrays.stream(arr).boxed().collect(Collectors.toList()); //1.调用Arrays.stream()将int[]变为IntStream流,注意不能用Stre....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575442558951.html","articleImg1URL":"https://img.hacpai.com/bing/20180101.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"【C++】STL常用容器总结之五：双端队列deque","articleAbstractText":"6、双端队列 deque 所谓的 deque 是\u201ddouble ended queue\u201d的缩写，双端队列不论在尾部或头部插入元素，都十分迅速。而在中间插入元素则会比较费时，因为必须移动中间其他的元素。双端队列是一种随机访问的数据类型，提供了在序列两端快速插入和删除操作的功能，它可以在需要的时候改变自身大小，完成了标准的 C++ 数据结构中队列的所有功能。 Vector 是单向开口的连续线性空间，deque 则是一种双向开口的连续线性空间。deque 对象在队列的两端放置元素和删除元素是高效的，而向量 vector 只是在插入序列的末尾时操作才是高效的。deque 和 vector 的最大差异，一在于 deque 允许于常数时间内对头端进行元素的插入或移除操作，二在于 deque 没有所谓的 capacity 观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。换句话说，像 vector 那样\u201c因旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间\u201d这样的事情在 deque 中是不会发生的。也因此，deque 没有必要提供所谓的空间预留（reserve....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575382986055.html","articleImg1URL":"https://img.hacpai.com/bing/20190118.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"【C++】STL常用容器总结之六：基于deque的顺序容器适配器","articleAbstractText":"7、基于 deque 的顺序容器适配器 1、stack 的基本概念 Stack 即栈，允许新增元素、移除元素、取得最顶端元素。但除了最顶端外，没有任何其他方法可以存取 stack 的其他元素，换言之，stack 不允许随机访问。可以将 stack 看成是封闭了一端开口的 deque。 将元素插入 stack 的操作称为 push，将元素弹出 stack 的操作称为 pop。Stack 所有元素的进出都必须符合\u201c后进先出\u201d的条件，只有 stack 顶端的元素，才有机会被外界取用。stack 不提供走访功能，也不提供迭代器。 2、堆栈类 stack 的成员函数 stack 实现后进先出的操作，使用时应包含头文件：#include&lt;stack&gt;。 声明一个 stack 对象：std::stack&lt;type,container&gt; stk; stack 模板类需要两个模板参数，一个是元素类型，一个容器类型，但只有元素类型是必要的。type 为堆栈操作的数据元素类型，container 为实现堆栈所用的容器类型，在不指定容器类型时，默认的容器类型为 deque，还可以为 s....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575383105229.html","articleImg1URL":"https://img.hacpai.com/file/2019/12/20160825111249201-a1f80a63.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"},{"articleTitle":"【C++】STL常用容器总结之四：链表list","articleAbstractText":"5、链表 list List 是每个节点包含前驱指针、后继指针和数据域三个部分的双向链表。List 不提供随机存取，访问元素需要按顺序走到需存取的元素，时间复杂度为 O(n)，在 list 的任何位置上执行插入或删除操作都非常迅速，只需在 list 内部调整一下指针。list 不仅是一个双向链表，而且还是一个环状双向链表。所以它只需要一个指针，便可以完整实现整个链表。（这里需要特别强调一下：list 到底是不是双向链表？有的书上说是，有的书上没说，所以大家注意一下，这里暂把 list 当作双向链表，等博主找到资料再做解释） 与向量 vector 相比，list 允许快速的插入和删除，且每次插入或删除一个元素，就配置或释放一个元素空间，对于任何位置的元素插入或元素移除，list 永远是常数时间。 List 不再能够像 vector 那样以普通指针作为迭代器，因为其节点不保证在储存空间中连续存在。list 迭代器必须有能力指向 list 的节点，并有能力进行正确的递增、递减、取值、成员存取等操作。所谓 list 迭代器正确的递增、递减、取值、成员取用操作是指，递增时指向下一个节点，递减时指....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575382915839.html","articleImg1URL":"https://img.hacpai.com/bing/20180404.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}