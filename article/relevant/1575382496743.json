{"relevantArticles":[{"articleTitle":"JAVA正则表达式总结","articleAbstractText":"正则表达式匹配常用字符（只含常用）： 字符：   x 字符x   \\n 新行（换行）符 ('\\u000A')   \\t 制表符 ('\\u0009')  字符类：   [abc] a、b 或 c（简单类）   [^abc] 任何字符，除了 a、b 或 c（否定）   [a-zA-Z] a 到 z 或 A 到 Z，两头的字母包括在内（范围）   [a-d[m-p]] a 到 d 或 m 到 p：[a-dm-p]（并集） |   [a-z&amp;&amp;[def]] d、e 或 f（交集）   [a-z&amp;&amp;[^bc]] a 到 z，除了 b 和 c：[ad-z]（减去）   [a-z&amp;&amp;[^m-p]] a 到 z，而非 m 到 p：[a-lq-z]（减去）  预定义字符类：   . 任何字符（与行结束符可能匹配也可能不匹配）   \\d 数字：[0-9]   \\D 非数字： [^0-9]   \\s 空白字符：[ \\t\\n\\x0B\\f\\r]   \\S 非空白字符：[^\\s]   \\w 单词字符：[a-zA-Z_0-9]    \\W 非单词字符：[^\\w]  边....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575442507093.html","articleImg1URL":"https://img.hacpai.com/bing/20181229.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"Emmet常用语法","articleAbstractText":"官方文档：https://docs.emmet.io/cheat-sheet  HTML 初始结构(!) 先输入！然后按 tab 生成基础结构  id(#)和 class(.)  div#test &lt;div id=\"test\"&gt;&lt;/div&gt; div.test &lt;div class=\"test\"&gt;&lt;/div&gt; form#search.wide &lt;form id=\"search\" class=\"wide\"&gt;&lt;/form&gt; p.class1.class2.class3 &lt;p class=\"class1 class2 class3\"&gt;&lt;/p&gt;  子节点(&gt;)，兄弟结点(+)，上级节点(^)  div&gt;ul&gt;li&gt;p  &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;   div+ul+p  &lt;div&gt;&lt;/div&gt; &lt;....","articleStatus":0,"articlePermalink":"/articles/2020/01/01/1577858373027.html","articleImg1URL":"https://img.hacpai.com/file/2020/01/p20200101013412-55772897.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"},{"articleTitle":"【C++】STL常用容器总结之五：双端队列deque","articleAbstractText":"6、双端队列 deque 所谓的 deque 是\u201ddouble ended queue\u201d的缩写，双端队列不论在尾部或头部插入元素，都十分迅速。而在中间插入元素则会比较费时，因为必须移动中间其他的元素。双端队列是一种随机访问的数据类型，提供了在序列两端快速插入和删除操作的功能，它可以在需要的时候改变自身大小，完成了标准的 C++ 数据结构中队列的所有功能。 Vector 是单向开口的连续线性空间，deque 则是一种双向开口的连续线性空间。deque 对象在队列的两端放置元素和删除元素是高效的，而向量 vector 只是在插入序列的末尾时操作才是高效的。deque 和 vector 的最大差异，一在于 deque 允许于常数时间内对头端进行元素的插入或移除操作，二在于 deque 没有所谓的 capacity 观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。换句话说，像 vector 那样\u201c因旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间\u201d这样的事情在 deque 中是不会发生的。也因此，deque 没有必要提供所谓的空间预留（reserve....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575382986055.html","articleImg1URL":"https://img.hacpai.com/bing/20190118.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"【C++】STL常用容器总结之四：链表list","articleAbstractText":"5、链表 list List 是每个节点包含前驱指针、后继指针和数据域三个部分的双向链表。List 不提供随机存取，访问元素需要按顺序走到需存取的元素，时间复杂度为 O(n)，在 list 的任何位置上执行插入或删除操作都非常迅速，只需在 list 内部调整一下指针。list 不仅是一个双向链表，而且还是一个环状双向链表。所以它只需要一个指针，便可以完整实现整个链表。（这里需要特别强调一下：list 到底是不是双向链表？有的书上说是，有的书上没说，所以大家注意一下，这里暂把 list 当作双向链表，等博主找到资料再做解释） 与向量 vector 相比，list 允许快速的插入和删除，且每次插入或删除一个元素，就配置或释放一个元素空间，对于任何位置的元素插入或元素移除，list 永远是常数时间。 List 不再能够像 vector 那样以普通指针作为迭代器，因为其节点不保证在储存空间中连续存在。list 迭代器必须有能力指向 list 的节点，并有能力进行正确的递增、递减、取值、成员存取等操作。所谓 list 迭代器正确的递增、递减、取值、成员取用操作是指，递增时指向下一个节点，递减时指....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575382915839.html","articleImg1URL":"https://img.hacpai.com/bing/20180404.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"【C++】STL常用容器总结之七：对组pair与关联容器","articleAbstractText":"8、对组 pair 在这部分，我们先介绍一下对组 pair 与关联容器，之后再介绍常用的几个具体的关联容器。 1、关联容器 关联容器是存储对象集合的类型，支持通过键的高效查询。关联容器的大部分行为与顺序容器相同，二者的本质区别在于关联容器通过键存储和读取元素，而顺序容器是通过元素在容器中的位置顺序存储和访问元素。 关联容器的每个元素包含一个键值（key）和一个实值（value）。当元素被插入到关联容器中时，容器内部数据结构便依照其键值大小，以某种特定规则将这个元素放置于适当位置。关联容器没有所谓的头尾，只有最大元素和最小元素，关联容器不提供 front、push_front、pop_front、back、push_back、以及 pop_back 操作。 标准的 STL 关联容器分为 set（集合）和 map（映射）两大类，以及这两大类的衍生体 multiset（多键集合）和 multimap（多键映射表）。这些容器的底层机制均以 RB-tree 完成（红黑树）。 2、关联容器与顺序容器的公共操作 1、关联容器与顺序容器共享的构造函数 关联容器共享大部分顺序容器的操作，但不是全部，关联....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575383191775.html","articleImg1URL":"https://img.hacpai.com/bing/20180709.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}