{"relevantArticles":[{"articleTitle":"【C++】STL常用容器总结之六：基于deque的顺序容器适配器","articleAbstractText":"7、基于 deque 的顺序容器适配器 1、stack 的基本概念 Stack 即栈，允许新增元素、移除元素、取得最顶端元素。但除了最顶端外，没有任何其他方法可以存取 stack 的其他元素，换言之，stack 不允许随机访问。可以将 stack 看成是封闭了一端开口的 deque。 将元素插入 stack 的操作称为 push，将元素弹出 stack 的操作称为 pop。Stack 所有元素的进出都必须符合\u201c后进先出\u201d的条件，只有 stack 顶端的元素，才有机会被外界取用。stack 不提供走访功能，也不提供迭代器。 2、堆栈类 stack 的成员函数 stack 实现后进先出的操作，使用时应包含头文件：#include&lt;stack&gt;。 声明一个 stack 对象：std::stack&lt;type,container&gt; stk; stack 模板类需要两个模板参数，一个是元素类型，一个容器类型，但只有元素类型是必要的。type 为堆栈操作的数据元素类型，container 为实现堆栈所用的容器类型，在不指定容器类型时，默认的容器类型为 deque，还可以为 s....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575383105229.html","articleImg1URL":"https://img.hacpai.com/file/2019/12/20160825111249201-a1f80a63.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"},{"articleTitle":"JAVA正则表达式总结","articleAbstractText":"正则表达式匹配常用字符（只含常用）： 字符：   x 字符x   \\n 新行（换行）符 ('\\u000A')   \\t 制表符 ('\\u0009')  字符类：   [abc] a、b 或 c（简单类）   [^abc] 任何字符，除了 a、b 或 c（否定）   [a-zA-Z] a 到 z 或 A 到 Z，两头的字母包括在内（范围）   [a-d[m-p]] a 到 d 或 m 到 p：[a-dm-p]（并集） |   [a-z&amp;&amp;[def]] d、e 或 f（交集）   [a-z&amp;&amp;[^bc]] a 到 z，除了 b 和 c：[ad-z]（减去）   [a-z&amp;&amp;[^m-p]] a 到 z，而非 m 到 p：[a-lq-z]（减去）  预定义字符类：   . 任何字符（与行结束符可能匹配也可能不匹配）   \\d 数字：[0-9]   \\D 非数字： [^0-9]   \\s 空白字符：[ \\t\\n\\x0B\\f\\r]   \\S 非空白字符：[^\\s]   \\w 单词字符：[a-zA-Z_0-9]    \\W 非单词字符：[^\\w]  边....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575442507093.html","articleImg1URL":"https://img.hacpai.com/bing/20181229.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"rope基本操作","articleAbstractText":"在 g++ 头文件中，&lt;ext/rope&gt; 中有成型的块状链表，在 using namespace __gnu_cxx;空间中，其操作十分方便。 基本操作： rope test; test.push_back(x);//在末尾添加 x test.insert(pos,x);//在 pos 插入 x　　 test.erase(pos,x);//从 pos 开始删除 x 个 test.copy(pos,len,x);//从 pos 开始到 pos+len 为止用 x 代替 test.replace(pos,x);//从 pos 开始换成 x test.substr(pos,x);//提取 pos 开始 x 个 test.at(x)/[x];//访问第 x 个元素 其算法复杂度 n*(n^0.5)，可以在很短的时间内实现快速的插入、删除和查找字符串，是一个很厉害的神器！","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575383226457.html","articleImg1URL":"https://img.hacpai.com/bing/20190504.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"Emmet常用语法","articleAbstractText":"官方文档：https://docs.emmet.io/cheat-sheet  HTML 初始结构(!) 先输入！然后按 tab 生成基础结构  id(#)和 class(.)  div#test &lt;div id=\"test\"&gt;&lt;/div&gt; div.test &lt;div class=\"test\"&gt;&lt;/div&gt; form#search.wide &lt;form id=\"search\" class=\"wide\"&gt;&lt;/form&gt; p.class1.class2.class3 &lt;p class=\"class1 class2 class3\"&gt;&lt;/p&gt;  子节点(&gt;)，兄弟结点(+)，上级节点(^)  div&gt;ul&gt;li&gt;p  &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;   div+ul+p  &lt;div&gt;&lt;/div&gt; &lt;....","articleStatus":0,"articlePermalink":"/articles/2020/01/01/1577858373027.html","articleImg1URL":"https://img.hacpai.com/file/2020/01/p20200101013412-55772897.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"},{"articleTitle":"【C++】STL常用容器总结之七：对组pair与关联容器","articleAbstractText":"8、对组 pair 在这部分，我们先介绍一下对组 pair 与关联容器，之后再介绍常用的几个具体的关联容器。 1、关联容器 关联容器是存储对象集合的类型，支持通过键的高效查询。关联容器的大部分行为与顺序容器相同，二者的本质区别在于关联容器通过键存储和读取元素，而顺序容器是通过元素在容器中的位置顺序存储和访问元素。 关联容器的每个元素包含一个键值（key）和一个实值（value）。当元素被插入到关联容器中时，容器内部数据结构便依照其键值大小，以某种特定规则将这个元素放置于适当位置。关联容器没有所谓的头尾，只有最大元素和最小元素，关联容器不提供 front、push_front、pop_front、back、push_back、以及 pop_back 操作。 标准的 STL 关联容器分为 set（集合）和 map（映射）两大类，以及这两大类的衍生体 multiset（多键集合）和 multimap（多键映射表）。这些容器的底层机制均以 RB-tree 完成（红黑树）。 2、关联容器与顺序容器的公共操作 1、关联容器与顺序容器共享的构造函数 关联容器共享大部分顺序容器的操作，但不是全部，关联....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575383191775.html","articleImg1URL":"https://img.hacpai.com/bing/20180709.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}