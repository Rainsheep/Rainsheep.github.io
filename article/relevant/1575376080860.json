{"relevantArticles":[{"articleTitle":"矩形的交面积","articleAbstractText":"矩形边平行 X 轴或 Y 轴 输入：矩形某对角线上两个点 输出：交面积 #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; int main() { double x1,y1,x2,y2; double x3,y3,x4,y4; double m1,m2,n1,n2; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;x3&gt;&gt;y3&gt;&gt;x4&gt;&gt;y4; m1=min(max(x1,x2),max(x3,x4)); n1=min(max(y1,y2),max(y3,y4)); m2=max(min(x1,x2),min(x3,x4)); n2=max(min(y1,y2),min(y3,y4)); if(m1&gt;m2&amp;&amp;n1&gt;n2) { cout&lt;&lt;(m1-m2)*(n1-n2)&lt;&lt;endl; } else cout&lt;&lt;\"0.00\"&lt;&lt;endl; r....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575440043701.html","articleImg1URL":"https://img.hacpai.com/bing/20190211.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"素数判断","articleAbstractText":"bool is_prime(int u) { if (u == 0 || u == 1)return false; if (u == 2)return true; if (u % 2 == 0)return false; for (int i = 3; i &lt;= sqrt(u); i += 2) if (u%i == 0)return false; return true; }","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575440129024.html","articleImg1URL":"https://img.hacpai.com/bing/20190312.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"拓扑排序 最短工期 PTA","articleAbstractText":"题目： 一个项目由若干个任务组成，任务之间有先后依赖顺序。项目经理需要设置一系列里程碑，在每个里程碑节点处检查任务的完成情况，并启动后续的任务。现给定一个项目中各个任务之间的关系，请你计算出这个项目的最早完工时间。 输入格式： 首先第一行给出两个正整数：项目里程碑的数量 N（≤）和任务总数 M。这里的里程碑从 0 到 N−1 编号。随后 M 行，每行给出一项任务的描述，格式为\u201c任务起始里程碑 任务结束里程碑 工作时长\u201d，三个数字均为非负整数，以空格分隔。 输出格式： 如果整个项目的安排是合理可行的，在一行中输出最早完工时间；否则输出\"Impossible\"。 输入样例 1： 9 12 0 1 6 0 2 4 0 3 5 1 4 1 2 4 1 3 5 2 5 4 0 4 6 9 4 7 7 5 7 4 6 8 2 7 8 4  输出样例 1： 18  输入样例 2： 4 5 0 1 1 0 2 2 2 1 3 1 3 4 3 2 5  输出样例 2： Impossible  判断一个图是否为有向无环图的算法：  定义一个队列 Q，并把所有入度为 0 的结点加入队列。 取队首结点，输出，....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575377857089.html","articleImg1URL":"https://img.hacpai.com/bing/20190610.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"分解质因子","articleAbstractText":"任何一个合数可以分解为几个质数的乘积，这些质数也必然是这个合数的约数。 超时模板： #include&lt;bits/stdc++.h&gt; using namespace std; vector&lt;int&gt; fun(int n) { vector&lt;int&gt; v; for (int i = 2; i &lt;= n; i++) { while (n%i == 0) { n /= i; v.push_back(i); } } return v; } int main() { int n; cin &gt;&gt; n; vector&lt;int&gt; v = fun(n); for (auto it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } }  优化模板： #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;cmath&gt; using namespace std; vector&lt;int....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575440099127.html","articleImg1URL":"https://img.hacpai.com/bing/20180317.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"最小生成树模板","articleAbstractText":"prim 算法 按点算，适合于点少的情况 邻接矩阵，时间复杂度 o(n^2) //PTA公路村村通 #include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; const int INF = 0x3fffffff; const int MAXV = 1005; int G[MAXV][MAXV], d[MAXV];//G存两个城镇直接的距离，d存已标记点到此点的最短距离 bool vis[MAXV];//vis存是否被标记过 int prim(int n) { int ans = 0;//边权最小值  fill(vis,vis+MAXV,false); fill(d, d + MAXV, INF); d[1] = 0;//从第一个城镇开始  for (int i = 0; i &lt; n; i++)//n个点，循环n次  { int u = -1, Min = INF;//Min存放最小d[u],u点的d[u]最小  for (int j = 1; j &lt;= n; j++)//寻找未访问点中最小d[]....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575375922893.html","articleImg1URL":"https://img.hacpai.com/bing/20171126.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}