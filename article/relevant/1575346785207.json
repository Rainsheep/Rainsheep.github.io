{"relevantArticles":[{"articleTitle":"背包模板","articleAbstractText":"模板 /** * 多重背包： * 有N种物品和一个容量为 V的背包。第i种物品最多有 num[i]件可用， * 每件耗费的空间是C[i]，价值是W[i]。 * 求解将哪些物品装入背包可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。 */ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; #define maxn 100005 int c[maxn], w[maxn], num[maxn];//c:费用 w:价值 num:数量 int dp[maxn]; //当前位置符合题意的最优解 int V; //V:总容量  //01背包 void ZeroOnePack(int c, int w) { for (int v = V; v &gt;= c; v--) { dp[v] = max(dp[v], dp[v - c] + w); } } //完全背包 void CompletePack(int c, int w) { for (i....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575375623459.html","articleImg1URL":"https://img.hacpai.com/bing/20190928.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"素数判断","articleAbstractText":"bool is_prime(int u) { if (u == 0 || u == 1)return false; if (u == 2)return true; if (u % 2 == 0)return false; for (int i = 3; i &lt;= sqrt(u); i += 2) if (u%i == 0)return false; return true; }","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575440129024.html","articleImg1URL":"https://img.hacpai.com/bing/20190312.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"LIS（最长上升子序列）","articleAbstractText":"方法一： dp 动态规划 状态设计：dp[i]代表以 a[i]结尾的 LIS 的长度 状态转移：dp[i]=max(dp[i], dp[j]+1) (0&lt;=j&lt; i, a[j]&lt; a[i]) 时间复杂度：O(N^2) 例题：https://blog.csdn.net/y201619819/article/details/78354348 方法二：贪心 + 二分 时间复杂度 Nlog(N) a[i]表示第 i 个数据。 dp[i]表示表示长度为 i+1 的 LIS 结尾元素的最小值。 利用贪心的思想，对于一个上升子序列，显然当前最后一个元素越小，越有利于添加新的元素，这样 LIS 长度自然更长。 因此，我们只需要维护 dp 数组，其表示的就是长度为 i+1 的 LIS 结尾元素的最小值，保证每一位都是最小值，这样子 dp 数组的长度就是 LIS 的长度。 dp 数组具体维护过程同样举例讲解更为清晰。 同样对于序列 a(1, 7, 3, 5, 9, 4, 8)，dp 的变化过程如下： dp[0] = a[0] = 1，长度为 1 的 LIS 结尾元素的最小值自然没得挑，就....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575436974755.html","articleImg1URL":"https://img.hacpai.com/bing/20180917.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"容斥定理","articleAbstractText":"要计算几个集合并集的大小，我们要先将所有单个集合的大小计算出来，然后减去所有两个集合相交的部分，再加回所有三个集合相交的部分，再减去所有四个集合相交的部分，依此类推，一直计算到所有集合相交的部分。 简单来说，就是奇加偶减。  举个例子： 求 1~n 中多少个数不是 2,3,5,7 的倍数，当 n=10,结果只有 1 一个数。 #include&lt;iostream&gt; using namespace std; int main() { int n; cin&gt;&gt;n; int ans=n-(n/2+n/3+n/5+n/7)+(n/2/3+n/2/5+n/2/7+n/3/5+n/3/7+n/5/7)-(n/2/3/5+n/2/3/7+n/3/5/7+n/2/5/7)+n/2/3/5/7; //ans=n-(n/2+n/3+n/5+n/7)+(n/6+n/10+n/14+n/15+n/21+n/35)-(n/30+n/42+n/105+n/70)+n/210  cout&lt;&lt;ans&lt;&lt;endl; return 0; }  例子 2： 题目描述： V_Dr....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575440265389.html","articleImg1URL":"https://img.hacpai.com/file/2019/12/20190402164825432-bffcedb6.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"},{"articleTitle":"分解质因子","articleAbstractText":"任何一个合数可以分解为几个质数的乘积，这些质数也必然是这个合数的约数。 超时模板： #include&lt;bits/stdc++.h&gt; using namespace std; vector&lt;int&gt; fun(int n) { vector&lt;int&gt; v; for (int i = 2; i &lt;= n; i++) { while (n%i == 0) { n /= i; v.push_back(i); } } return v; } int main() { int n; cin &gt;&gt; n; vector&lt;int&gt; v = fun(n); for (auto it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } }  优化模板： #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;cmath&gt; using namespace std; vector&lt;int....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575440099127.html","articleImg1URL":"https://img.hacpai.com/bing/20180317.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}