{"relevantArticles":[{"articleTitle":"背包模板","articleAbstractText":"模板 /** * 多重背包： * 有N种物品和一个容量为 V的背包。第i种物品最多有 num[i]件可用， * 每件耗费的空间是C[i]，价值是W[i]。 * 求解将哪些物品装入背包可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。 */ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; #define maxn 100005 int c[maxn], w[maxn], num[maxn];//c:费用 w:价值 num:数量 int dp[maxn]; //当前位置符合题意的最优解 int V; //V:总容量  //01背包 void ZeroOnePack(int c, int w) { for (int v = V; v &gt;= c; v--) { dp[v] = max(dp[v], dp[v - c] + w); } } //完全背包 void CompletePack(int c, int w) { for (i....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575375623459.html","articleImg1URL":"https://img.hacpai.com/bing/20190928.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"拦截导弹（规律：下降子序列的个数等于最长上升子序列的长度）","articleAbstractText":"问题描述 　　某国为了防御敌国的导弹袭击，发展出一种导弹 拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的 导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。 　　输入导弹依次飞来的高度（雷达给出的高度数据是不大于 30000 的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入格式 　　一行，为导弹依次飞来的高度 输出格式 　　两行，分别是最多能拦截的导弹数与要拦截所有导弹最少要配备的系统数 样例输入 389 207 155 300 299 170 158 65 样例输出 6 2 规律：下降子序列的个数等于最长上升子序列的长度 #include &lt;iostream&gt;  using namespace std; int main() { int a[1005]; int d[1005]; int i=1; while(cin&gt;&gt;a[i]) { i++; } int n=i; int ma....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575376746513.html","articleImg1URL":"https://img.hacpai.com/bing/20190207.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"邮票","articleAbstractText":"问题描述 　　给定一个信封，有 N（1≤ N≤100）个位置可以贴邮票，每个位置只能贴一张邮票。我们现在有 M(M&lt; =100)种不同邮资的邮票，面值为 X1,X2\u2026.Xm 分（Xi 是整数，1≤ Xi≤255），每种都有 N 张。 　　显然，信封上能贴的邮资最小值是 min(X1, X2, \u2026, Xm)，最大值是 N*max(X1, X2, \u2026,　　Xm)。由所有贴法得到的邮资值可形成一个集合（集合中没有重复数值），要求求出这个集合中是否存在从 1 到某个值的连续邮资序列，输出这个序列的 最大值。 　　例如，N=4，M=2，面值分别为 4 分，1 分，于是形成 1，2，3，4，5，6，7，8，9，10，12，13，16 的序列，而从 1 开始的连续邮资序列为 1，2，3，4，5，6，7，8，9，10，所以连续邮资序列的最大值为 10 分。 输入格式 　　第一行：最多允许粘贴的邮票张数 N；第二行：邮票种数 M；第三行：空格隔开的 M 个数字，表示邮票的面值 Xi。注意：Xi 序列不一定是大小有序的！ 输出格式 　　从 1 开始的连续邮资序列的最大值 MAX。若不存在从 1 分开....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575376583745.html","articleImg1URL":"https://img.hacpai.com/bing/20190309.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"分解质因子","articleAbstractText":"任何一个合数可以分解为几个质数的乘积，这些质数也必然是这个合数的约数。 超时模板： #include&lt;bits/stdc++.h&gt; using namespace std; vector&lt;int&gt; fun(int n) { vector&lt;int&gt; v; for (int i = 2; i &lt;= n; i++) { while (n%i == 0) { n /= i; v.push_back(i); } } return v; } int main() { int n; cin &gt;&gt; n; vector&lt;int&gt; v = fun(n); for (auto it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } }  优化模板： #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;cmath&gt; using namespace std; vector&lt;int....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575440099127.html","articleImg1URL":"https://img.hacpai.com/bing/20180317.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"矩形的交面积","articleAbstractText":"矩形边平行 X 轴或 Y 轴 输入：矩形某对角线上两个点 输出：交面积 #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; int main() { double x1,y1,x2,y2; double x3,y3,x4,y4; double m1,m2,n1,n2; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;x3&gt;&gt;y3&gt;&gt;x4&gt;&gt;y4; m1=min(max(x1,x2),max(x3,x4)); n1=min(max(y1,y2),max(y3,y4)); m2=max(min(x1,x2),min(x3,x4)); n2=max(min(y1,y2),min(y3,y4)); if(m1&gt;m2&amp;&amp;n1&gt;n2) { cout&lt;&lt;(m1-m2)*(n1-n2)&lt;&lt;endl; } else cout&lt;&lt;\"0.00\"&lt;&lt;endl; r....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575440043701.html","articleImg1URL":"https://img.hacpai.com/bing/20190211.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}