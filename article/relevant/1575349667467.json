{"relevantArticles":[{"articleTitle":"分解质因子","articleAbstractText":"任何一个合数可以分解为几个质数的乘积，这些质数也必然是这个合数的约数。 超时模板： #include&lt;bits/stdc++.h&gt; using namespace std; vector&lt;int&gt; fun(int n) { vector&lt;int&gt; v; for (int i = 2; i &lt;= n; i++) { while (n%i == 0) { n /= i; v.push_back(i); } } return v; } int main() { int n; cin &gt;&gt; n; vector&lt;int&gt; v = fun(n); for (auto it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } }  优化模板： #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;cmath&gt; using namespace std; vector&lt;int....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575440099127.html","articleImg1URL":"https://img.hacpai.com/bing/20180317.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"阶乘末尾0的个数","articleAbstractText":"题目描述 求：S=1！×2！×3！×...× n！的末尾有多少个零。 输入描述： 输入数据共一行，一个正整数 n，意义如\u201c问题描述\u201d。 输出描述： 输出一行描述答案： 一个正整数 k，表示 S 的末尾有 k 个 0 示例 1 输入 10 输出 7 说明 对于 100% 的数据，1≤ n≤100,000,000 思路：观察这个表达式我们发现 0 的个数即为该表达式的最终结果含有 10 的几次方的因子。我们就联想到了拆素数。并且 10 的 n 次方都有一个通性：质因子只有 2 和 5。显而易见，最终结果中质因子 2 的个数远远大于 5 的个数。所以这道题就是找因子 5 的个数。由于是阶乘的连乘，后一个数 a 都比前一个数(a-1)多乘了个 a。我们的目标是找 5 的个数，也就是每五个一循环，更新每次乘上的 5 的个数。 #include&lt;iostream&gt; using namespace std; int main() { int n; long long ans = 0; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { in....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575380460268.html","articleImg1URL":"https://img.hacpai.com/bing/20190513.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"组合数C(n,m)的计算","articleAbstractText":"C(n,m)的计算方式： 1.公式：C(n,m) = n!/((n-m)! * m!)，在算法上较难实现，阶乘很快会爆 long long 2.递推：C(n,m) = C(n-1,m-1) + C(n-1,m) 在算法上当然会采用第二种方式计算，而且因为 C(n,m)本身值很大，所以大多数碰见它的情况会取模 #include&lt;iostream&gt; #define MOD 1000000007 using namespace std; const int N = 10005; long long c[N][N]; long long C(int i, int j) { if (i == j) return c[i][j] = 1; if (j == 0) return c[i][j] = 1; if (j == 1) return c[i][j] = i; if (c[i][j]) return c[i][j]; return c[i][j] = (C(i - 1, j - 1) % MOD + C(i - 1, j) % MOD) % MOD;//不需取模时把MOD去掉 } ....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575379716365.html","articleImg1URL":"https://img.hacpai.com/bing/20191106.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"牛客多校第五次-G题-max","articleAbstractText":"题目描述 Give two positive integer c, n. You need to find a pair of integer (a,b) satisfy 1&lt;=a,b&lt;=n and the greatest common division of a and b is c.And you need to maximize the product of a and b 输入描述： The first line has two positive integer c,n 输出描述： Output the maximum product of a and b. If there are no such a and b, just output -1 示例 1 输入 2 4  输出 8  说明 a=2,b=4  备注： 1&lt;=c,n&lt;=10^9  题目描述 给定两个正整数 c,n，求一个数对 (a,b)，满足 1&lt;=a,b&lt;=n，且 gcd(a,b)=c 要求输出最大的 ab,不存在则输出-1 1&lt;=c,n&lt;=10^9 解题思路 首....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575384591995.html","articleImg1URL":"https://img.hacpai.com/bing/20190516.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"莫队算法 牛客多校赛题","articleAbstractText":"题目描述 Given a sequence of integers a 1 , a 2 , ..., a n and q pairs of integers (l 1 , r 1 ), (l 2 , r 2 ), ..., (l q , r q ), find count(l 1 , r 1 ), count(l 2 , r 2 ), ..., count(l q , r q ) where count(i, j) is the number of different integers among a 1 , a 2 , ..., a i , a j , a j + 1 , ..., a n . 输入描述： The input consists of several test cases and is terminated by end-of-file. The first line of each test cases contains two integers n and q. The second line contains n integers a 1 , a 2 , ...,....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575439848633.html","articleImg1URL":"https://img.hacpai.com/bing/20171129.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}