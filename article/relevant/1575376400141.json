{"relevantArticles":[{"articleTitle":"JAVA正则表达式总结","articleAbstractText":"正则表达式匹配常用字符（只含常用）： 字符：   x 字符x   \\n 新行（换行）符 ('\\u000A')   \\t 制表符 ('\\u0009')  字符类：   [abc] a、b 或 c（简单类）   [^abc] 任何字符，除了 a、b 或 c（否定）   [a-zA-Z] a 到 z 或 A 到 Z，两头的字母包括在内（范围）   [a-d[m-p]] a 到 d 或 m 到 p：[a-dm-p]（并集） |   [a-z&amp;&amp;[def]] d、e 或 f（交集）   [a-z&amp;&amp;[^bc]] a 到 z，除了 b 和 c：[ad-z]（减去）   [a-z&amp;&amp;[^m-p]] a 到 z，而非 m 到 p：[a-lq-z]（减去）  预定义字符类：   . 任何字符（与行结束符可能匹配也可能不匹配）   \\d 数字：[0-9]   \\D 非数字： [^0-9]   \\s 空白字符：[ \\t\\n\\x0B\\f\\r]   \\S 非空白字符：[^\\s]   \\w 单词字符：[a-zA-Z_0-9]    \\W 非单词字符：[^\\w]  边....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575442507093.html","articleImg1URL":"https://img.hacpai.com/bing/20181229.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"POJ 1182 食物链 并查集","articleAbstractText":"题目链接：点击打开链接 思路：并查集判断是否有关系 类型一个三种 #include&lt;iostream&gt; #include&lt;string&gt; using namespace std; const int N = 500005; int father[N]; int sum = 0; int d[N] = { 0 };//代表与根节点的距离，有0,1,2三种 int n; int find(int x) {//find时更新距离  if (x != father[x]) { int pre = father[x]; father[x] = find(father[x]); d[x] += d[pre]; d[x] %= 3; } return father[x]; } int judge(int k, int x, int y) { int a = find(x); int b = find(y); if (a == b) { if (k == 1 &amp;&amp; d[x] != d[y])return 0; if (k == 2 &amp;&amp; d[x]....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575379403167.html","articleImg1URL":"https://img.hacpai.com/bing/20190610.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"IDAE记录","articleAbstractText":"快捷键 参考链接： Idea 快捷键大全    快捷键 功能     Ctrl+Y 删除光标所在行   Ctrl+D 复制光标所在行，插入光标位置下面   Ctrl+/ 单行注释，再按取消注释   Ctrl+Space 基本代码提示   Ctrl+O 覆盖重写方法   Ctrl+P 方法参数提示   Ctrl+N 查找类   Ctrl+左键 跳转到声明或用法   Ctrl+F12 显示当前文件的结构   Alt+Enter 导入包，自动修正代码   Alt+Insert 自动生成代码，toString，get，set 等方法   Shift+F6 重命名变量(所有此变量)   Alt+Shift+上下箭头 移动当前代码行   Ctrl+Shift+Space 智能代码提示   Ctrl+Shift+/ 注释选中代码，多行注释，再按取消注释   Ctrl + Shift + Enter 自动结束代码，行末自动添加分号   Ctrl + Alt + O 优化导入的类，可以对当前文件和整个包目录使用   Ctrl + Alt + 左键 跳转到实现   Ctrl+Alt+L 格式化代码   输....","articleStatus":0,"articlePermalink":"/articles/2020/01/07/1578385176961.html","articleImg1URL":"https://raw.githubusercontent.com/Rainsheep/pic-bed/master/img/2020-02-16+13:28:06+p_20200216012802.png?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"poj 2513 trie树","articleAbstractText":"题目大意： 输入木棒两端的颜色，一端颜色相同的木棒才能连接，问最后能不能连接成一根木棒 思路： 欧拉回路：如果图 G 中的一个路径包括每个边恰好一次，则该路径称为欧拉路径，如果一个回路是欧拉路径，则称为欧拉回路 无向图存在欧拉回路的充要条件 一个无向图存在欧拉回路，当且仅当该图所有顶点度数都为偶数，且该图是连通图。 有向图存在欧拉回路的充要条件 一个有向图存在欧拉回路，所有顶点的入度等于出度且该图是连通图。 本题用并查集判断是不是连通图，用 TRIE 树对应颜色相应的编号（map 超时） Sample Input blue red red violet cyan blue blue magenta magenta cyan Sample Output Possible #include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;string.h&gt; #include &lt;queue&gt; using name....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575379181032.html","articleImg1URL":"https://img.hacpai.com/bing/20180922.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"POJ 3630 TRIE树","articleAbstractText":"题目大意：一个数不能是另一个数开头的子串，trie 树 暴力解法：然后细细一想，既然是判断相同串是否存在，那我直接将串进行排序将第一位相同的串排在一起再进行判断操作，就大大优化了搜索时间。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;string&gt; #include&lt;algorithm&gt; using namespace std; string s[100005]; int main() { char p[12]; int t,flag=0,n,i,j; scanf(\"%d\",&amp;t); while(t--) { flag=0; scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++) { scanf(\"%s\",&amp;p); s[i]=p; } sort(s,s+n); for(int i=1;i&lt;n;i++) { if(s[i].size()&gt;s[i-1].size()) { for(j=0;j....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575379303995.html","articleImg1URL":"https://img.hacpai.com/bing/20190302.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}