{"relevantArticles":[{"articleTitle":"poj 2513 trie树","articleAbstractText":"题目大意： 输入木棒两端的颜色，一端颜色相同的木棒才能连接，问最后能不能连接成一根木棒 思路： 欧拉回路：如果图 G 中的一个路径包括每个边恰好一次，则该路径称为欧拉路径，如果一个回路是欧拉路径，则称为欧拉回路 无向图存在欧拉回路的充要条件 一个无向图存在欧拉回路，当且仅当该图所有顶点度数都为偶数，且该图是连通图。 有向图存在欧拉回路的充要条件 一个有向图存在欧拉回路，所有顶点的入度等于出度且该图是连通图。 本题用并查集判断是不是连通图，用 TRIE 树对应颜色相应的编号（map 超时） Sample Input blue red red violet cyan blue blue magenta magenta cyan Sample Output Possible #include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;string.h&gt; #include &lt;queue&gt; using name....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575379181032.html","articleImg1URL":"https://img.hacpai.com/bing/20180922.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"矩形的交面积","articleAbstractText":"矩形边平行 X 轴或 Y 轴 输入：矩形某对角线上两个点 输出：交面积 #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; int main() { double x1,y1,x2,y2; double x3,y3,x4,y4; double m1,m2,n1,n2; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;x3&gt;&gt;y3&gt;&gt;x4&gt;&gt;y4; m1=min(max(x1,x2),max(x3,x4)); n1=min(max(y1,y2),max(y3,y4)); m2=max(min(x1,x2),min(x3,x4)); n2=max(min(y1,y2),min(y3,y4)); if(m1&gt;m2&amp;&amp;n1&gt;n2) { cout&lt;&lt;(m1-m2)*(n1-n2)&lt;&lt;endl; } else cout&lt;&lt;\"0.00\"&lt;&lt;endl; r....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575440043701.html","articleImg1URL":"https://img.hacpai.com/bing/20190211.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"Trie树（Prefix Tree）介绍","articleAbstractText":"什么是 Trie 树 Trie 树，又叫字典树、前缀树（Prefix Tree）、单词查找树 或 键树，是一种多叉树结构。如下图：  上图是一棵 Trie 树，表示了关键字集合{\u201ca\u201d, \u201cto\u201d, \u201ctea\u201d, \u201cted\u201d, \u201cten\u201d, \u201ci\u201d, \u201cin\u201d, \u201cinn\u201d} 。从上图可以归纳出 Trie 树的基本性质：  根节点不包含字符，除根节点外的每一个子节点都包含一个字符。 从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。 每个节点的所有子节点包含的字符互不相同。  通常在实现的时候，会在节点结构中设置一个标志，用来标记该结点处是否构成一个单词（关键字）。 可以看出，Trie 树的关键字一般都是字符串，而且 Trie 树把每个关键字保存在一条路径上，而不是一个结点中。另外，两个有公共前缀的关键字，在 Trie 树中前缀部分的路径相同，所以 Trie 树又叫做前缀树（Prefix Tree）。 Trie 树的优缺点 Trie 树的核心思想是空间换时间，利用字符串的公共前缀来减少无谓的字符串比较以达到提高查询效率的目的。 优点   插入和查询的效率很高，都为，....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575379107462.html","articleImg1URL":"https://img.hacpai.com/file/2019/12/20150509003807271-06902728.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"},{"articleTitle":"poj 1703 并查集","articleAbstractText":"题目链接：点击打开链接 题目大意： 一共有 N 个人，给出 M 个操作分为两种： 1、A a b ：提问 a 和 b 是否是同一个帮派的。有三种答案：是，不是和不确定 2、D a b ：a 和 b 不是同一个帮派的。 解题思路： 种类并查集，在一个集合里的证明他们之间有关系，种类里有 0，和 1 两种。0 代表着同父节点相同势力，1 代表不同。 主要是不在同一集合时合并和查找操作； #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;string&gt; using namespace std; const int N = 100005; int vis[N];//与父节点属于同一帮派为0，不一帮派为1 int father[N]; int find(int x) {//每次find后vis的值将变正确  if (father[x] != x) { int t = find(father[x]); ////此处很重要，是通过这个节点与原来父节点的关系（是否是同一集合的问题）求这个节点现在与根节点的关系（异或关系）  v....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575379359668.html","articleImg1URL":"https://img.hacpai.com/bing/20171216.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"容斥定理","articleAbstractText":"要计算几个集合并集的大小，我们要先将所有单个集合的大小计算出来，然后减去所有两个集合相交的部分，再加回所有三个集合相交的部分，再减去所有四个集合相交的部分，依此类推，一直计算到所有集合相交的部分。 简单来说，就是奇加偶减。  举个例子： 求 1~n 中多少个数不是 2,3,5,7 的倍数，当 n=10,结果只有 1 一个数。 #include&lt;iostream&gt; using namespace std; int main() { int n; cin&gt;&gt;n; int ans=n-(n/2+n/3+n/5+n/7)+(n/2/3+n/2/5+n/2/7+n/3/5+n/3/7+n/5/7)-(n/2/3/5+n/2/3/7+n/3/5/7+n/2/5/7)+n/2/3/5/7; //ans=n-(n/2+n/3+n/5+n/7)+(n/6+n/10+n/14+n/15+n/21+n/35)-(n/30+n/42+n/105+n/70)+n/210  cout&lt;&lt;ans&lt;&lt;endl; return 0; }  例子 2： 题目描述： V_Dr....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575440265389.html","articleImg1URL":"https://img.hacpai.com/file/2019/12/20190402164825432-bffcedb6.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"}]}