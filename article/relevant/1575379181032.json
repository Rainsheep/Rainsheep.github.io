{"relevantArticles":[{"articleTitle":"POJ 3630 TRIE树","articleAbstractText":"题目大意：一个数不能是另一个数开头的子串，trie 树 暴力解法：然后细细一想，既然是判断相同串是否存在，那我直接将串进行排序将第一位相同的串排在一起再进行判断操作，就大大优化了搜索时间。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;string&gt; #include&lt;algorithm&gt; using namespace std; string s[100005]; int main() { char p[12]; int t,flag=0,n,i,j; scanf(\"%d\",&amp;t); while(t--) { flag=0; scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++) { scanf(\"%s\",&amp;p); s[i]=p; } sort(s,s+n); for(int i=1;i&lt;n;i++) { if(s[i].size()&gt;s[i-1].size()) { for(j=0;j....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575379303995.html","articleImg1URL":"https://img.hacpai.com/bing/20190302.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"素数判断","articleAbstractText":"bool is_prime(int u) { if (u == 0 || u == 1)return false; if (u == 2)return true; if (u % 2 == 0)return false; for (int i = 3; i &lt;= sqrt(u); i += 2) if (u%i == 0)return false; return true; }","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575440129024.html","articleImg1URL":"https://img.hacpai.com/bing/20190312.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"莫队算法 牛客多校赛题","articleAbstractText":"题目描述 Given a sequence of integers a 1 , a 2 , ..., a n and q pairs of integers (l 1 , r 1 ), (l 2 , r 2 ), ..., (l q , r q ), find count(l 1 , r 1 ), count(l 2 , r 2 ), ..., count(l q , r q ) where count(i, j) is the number of different integers among a 1 , a 2 , ..., a i , a j , a j + 1 , ..., a n . 输入描述： The input consists of several test cases and is terminated by end-of-file. The first line of each test cases contains two integers n and q. The second line contains n integers a 1 , a 2 , ...,....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575439848633.html","articleImg1URL":"https://img.hacpai.com/bing/20171129.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"矩形的交面积","articleAbstractText":"矩形边平行 X 轴或 Y 轴 输入：矩形某对角线上两个点 输出：交面积 #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; int main() { double x1,y1,x2,y2; double x3,y3,x4,y4; double m1,m2,n1,n2; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;x3&gt;&gt;y3&gt;&gt;x4&gt;&gt;y4; m1=min(max(x1,x2),max(x3,x4)); n1=min(max(y1,y2),max(y3,y4)); m2=max(min(x1,x2),min(x3,x4)); n2=max(min(y1,y2),min(y3,y4)); if(m1&gt;m2&amp;&amp;n1&gt;n2) { cout&lt;&lt;(m1-m2)*(n1-n2)&lt;&lt;endl; } else cout&lt;&lt;\"0.00\"&lt;&lt;endl; r....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575440043701.html","articleImg1URL":"https://img.hacpai.com/bing/20190211.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"poj 1703 并查集","articleAbstractText":"题目链接：点击打开链接 题目大意： 一共有 N 个人，给出 M 个操作分为两种： 1、A a b ：提问 a 和 b 是否是同一个帮派的。有三种答案：是，不是和不确定 2、D a b ：a 和 b 不是同一个帮派的。 解题思路： 种类并查集，在一个集合里的证明他们之间有关系，种类里有 0，和 1 两种。0 代表着同父节点相同势力，1 代表不同。 主要是不在同一集合时合并和查找操作； #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;string&gt; using namespace std; const int N = 100005; int vis[N];//与父节点属于同一帮派为0，不一帮派为1 int father[N]; int find(int x) {//每次find后vis的值将变正确  if (father[x] != x) { int t = find(father[x]); ////此处很重要，是通过这个节点与原来父节点的关系（是否是同一集合的问题）求这个节点现在与根节点的关系（异或关系）  v....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575379359668.html","articleImg1URL":"https://img.hacpai.com/bing/20171216.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}