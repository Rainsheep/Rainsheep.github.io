{"relevantArticles":[{"articleTitle":"莫队算法 牛客多校赛题","articleAbstractText":"题目描述 Given a sequence of integers a 1 , a 2 , ..., a n and q pairs of integers (l 1 , r 1 ), (l 2 , r 2 ), ..., (l q , r q ), find count(l 1 , r 1 ), count(l 2 , r 2 ), ..., count(l q , r q ) where count(i, j) is the number of different integers among a 1 , a 2 , ..., a i , a j , a j + 1 , ..., a n . 输入描述： The input consists of several test cases and is terminated by end-of-file. The first line of each test cases contains two integers n and q. The second line contains n integers a 1 , a 2 , ...,....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575439848633.html","articleImg1URL":"https://img.hacpai.com/bing/20171129.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"PAT排名汇总","articleAbstractText":"输入格式： 输入的第一行给出一个正整数 N（\\le≤100），代表考点总数。随后给出 N 个考点的成绩，格式为：首先一行给出正整数 K（\\le≤300），代表该考点的考生总数；随后 K 行，每行给出 1 个考生的信息，包括考号（由 13 位整数字组成）和得分（为[0,100]区间内的整数），中间用空格分隔。 输出格式： 首先在第一行里输出考生总数。随后输出汇总的排名表，每个考生的信息占一行，顺序为：考号、最终排名、考点编号、在该考点的排名。其中考点按输入给出的顺序从 1 到 N 编号。考生的输出须按最终排名的非递减顺序输出，获得相同分数的考生应有相同名次，并按考号的递增顺序输出。 输入样例： 2 5 1234567890001 95 1234567890005 100 1234567890003 95 1234567890002 77 1234567890004 85 4 1234567890013 65 1234567890011 25 1234567890014 100 1234567890012 85  输出样例： 9 1234567890005 1 1 1 1234567890....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575349541564.html","articleImg1URL":"https://img.hacpai.com/bing/20190331.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"矩形的交面积","articleAbstractText":"矩形边平行 X 轴或 Y 轴 输入：矩形某对角线上两个点 输出：交面积 #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; int main() { double x1,y1,x2,y2; double x3,y3,x4,y4; double m1,m2,n1,n2; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;x3&gt;&gt;y3&gt;&gt;x4&gt;&gt;y4; m1=min(max(x1,x2),max(x3,x4)); n1=min(max(y1,y2),max(y3,y4)); m2=max(min(x1,x2),min(x3,x4)); n2=max(min(y1,y2),min(y3,y4)); if(m1&gt;m2&amp;&amp;n1&gt;n2) { cout&lt;&lt;(m1-m2)*(n1-n2)&lt;&lt;endl; } else cout&lt;&lt;\"0.00\"&lt;&lt;endl; r....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575440043701.html","articleImg1URL":"https://img.hacpai.com/bing/20190211.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"分解质因子","articleAbstractText":"任何一个合数可以分解为几个质数的乘积，这些质数也必然是这个合数的约数。 超时模板： #include&lt;bits/stdc++.h&gt; using namespace std; vector&lt;int&gt; fun(int n) { vector&lt;int&gt; v; for (int i = 2; i &lt;= n; i++) { while (n%i == 0) { n /= i; v.push_back(i); } } return v; } int main() { int n; cin &gt;&gt; n; vector&lt;int&gt; v = fun(n); for (auto it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } }  优化模板： #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;cmath&gt; using namespace std; vector&lt;int....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575440099127.html","articleImg1URL":"https://img.hacpai.com/bing/20180317.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"HDU-1005 Number Sequence 循环结","articleAbstractText":"一开始的思路是遇到 11 就开始循环，后来发现，发现当 A=5555，B=666666 时数列是 1142142142142，这种情况不是以 11 开始循环的，依然超时就罢了，关按 11 判断的话就错了。因为两个结果都一定是 0 到 6 之间的数，所以一定会循环，而且循环节不会超过 7*7=49。（因为前面 2 个数若相同，则第三个之后的数必相同，而在 49 内必能找到 2 个相邻的数在前面出现过）。 题目链接：HDU-1005 #include&lt;stdio.h&gt; int main() { int i,a,b,m,n,l,f[50]; while(~scanf(\"%d %d %d\",&amp;a,&amp;b,&amp;n)&amp;&amp;n) { f[1]=f[2]=1; if(n&lt;=2)f[n]=1; if(n&gt;2) { while(n&gt;49) { n=n-49; } for(i=3;i&lt;=n;i++) { f[i]=(a*f[i-1]+b*f[i-2])%7; } } printf(\"%d\\n\",f[n]); } return 0; }","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575347335905.html","articleImg1URL":"https://img.hacpai.com/bing/20190508.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}