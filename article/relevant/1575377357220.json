{"relevantArticles":[{"articleTitle":"分解质因子","articleAbstractText":"任何一个合数可以分解为几个质数的乘积，这些质数也必然是这个合数的约数。 超时模板： #include&lt;bits/stdc++.h&gt; using namespace std; vector&lt;int&gt; fun(int n) { vector&lt;int&gt; v; for (int i = 2; i &lt;= n; i++) { while (n%i == 0) { n /= i; v.push_back(i); } } return v; } int main() { int n; cin &gt;&gt; n; vector&lt;int&gt; v = fun(n); for (auto it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } }  优化模板： #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;cmath&gt; using namespace std; vector&lt;int....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575440099127.html","articleImg1URL":"https://img.hacpai.com/bing/20180317.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"rope基本操作","articleAbstractText":"在 g++ 头文件中，&lt;ext/rope&gt; 中有成型的块状链表，在 using namespace __gnu_cxx;空间中，其操作十分方便。 基本操作： rope test; test.push_back(x);//在末尾添加 x test.insert(pos,x);//在 pos 插入 x　　 test.erase(pos,x);//从 pos 开始删除 x 个 test.copy(pos,len,x);//从 pos 开始到 pos+len 为止用 x 代替 test.replace(pos,x);//从 pos 开始换成 x test.substr(pos,x);//提取 pos 开始 x 个 test.at(x)/[x];//访问第 x 个元素 其算法复杂度 n*(n^0.5)，可以在很短的时间内实现快速的插入、删除和查找字符串，是一个很厉害的神器！","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575383226457.html","articleImg1URL":"https://img.hacpai.com/bing/20190504.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"矩形的交面积","articleAbstractText":"矩形边平行 X 轴或 Y 轴 输入：矩形某对角线上两个点 输出：交面积 #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; int main() { double x1,y1,x2,y2; double x3,y3,x4,y4; double m1,m2,n1,n2; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;x3&gt;&gt;y3&gt;&gt;x4&gt;&gt;y4; m1=min(max(x1,x2),max(x3,x4)); n1=min(max(y1,y2),max(y3,y4)); m2=max(min(x1,x2),min(x3,x4)); n2=max(min(y1,y2),min(y3,y4)); if(m1&gt;m2&amp;&amp;n1&gt;n2) { cout&lt;&lt;(m1-m2)*(n1-n2)&lt;&lt;endl; } else cout&lt;&lt;\"0.00\"&lt;&lt;endl; r....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575440043701.html","articleImg1URL":"https://img.hacpai.com/bing/20190211.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"【C++】STL常用容器总结之四：链表list","articleAbstractText":"5、链表 list List 是每个节点包含前驱指针、后继指针和数据域三个部分的双向链表。List 不提供随机存取，访问元素需要按顺序走到需存取的元素，时间复杂度为 O(n)，在 list 的任何位置上执行插入或删除操作都非常迅速，只需在 list 内部调整一下指针。list 不仅是一个双向链表，而且还是一个环状双向链表。所以它只需要一个指针，便可以完整实现整个链表。（这里需要特别强调一下：list 到底是不是双向链表？有的书上说是，有的书上没说，所以大家注意一下，这里暂把 list 当作双向链表，等博主找到资料再做解释） 与向量 vector 相比，list 允许快速的插入和删除，且每次插入或删除一个元素，就配置或释放一个元素空间，对于任何位置的元素插入或元素移除，list 永远是常数时间。 List 不再能够像 vector 那样以普通指针作为迭代器，因为其节点不保证在储存空间中连续存在。list 迭代器必须有能力指向 list 的节点，并有能力进行正确的递增、递减、取值、成员存取等操作。所谓 list 迭代器正确的递增、递减、取值、成员取用操作是指，递增时指向下一个节点，递减时指....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575382915839.html","articleImg1URL":"https://img.hacpai.com/bing/20180404.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"【C++】STL常用容器总结之七：对组pair与关联容器","articleAbstractText":"8、对组 pair 在这部分，我们先介绍一下对组 pair 与关联容器，之后再介绍常用的几个具体的关联容器。 1、关联容器 关联容器是存储对象集合的类型，支持通过键的高效查询。关联容器的大部分行为与顺序容器相同，二者的本质区别在于关联容器通过键存储和读取元素，而顺序容器是通过元素在容器中的位置顺序存储和访问元素。 关联容器的每个元素包含一个键值（key）和一个实值（value）。当元素被插入到关联容器中时，容器内部数据结构便依照其键值大小，以某种特定规则将这个元素放置于适当位置。关联容器没有所谓的头尾，只有最大元素和最小元素，关联容器不提供 front、push_front、pop_front、back、push_back、以及 pop_back 操作。 标准的 STL 关联容器分为 set（集合）和 map（映射）两大类，以及这两大类的衍生体 multiset（多键集合）和 multimap（多键映射表）。这些容器的底层机制均以 RB-tree 完成（红黑树）。 2、关联容器与顺序容器的公共操作 1、关联容器与顺序容器共享的构造函数 关联容器共享大部分顺序容器的操作，但不是全部，关联....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575383191775.html","articleImg1URL":"https://img.hacpai.com/bing/20180709.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}