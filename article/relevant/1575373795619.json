{"relevantArticles":[{"articleTitle":"容斥定理","articleAbstractText":"要计算几个集合并集的大小，我们要先将所有单个集合的大小计算出来，然后减去所有两个集合相交的部分，再加回所有三个集合相交的部分，再减去所有四个集合相交的部分，依此类推，一直计算到所有集合相交的部分。 简单来说，就是奇加偶减。  举个例子： 求 1~n 中多少个数不是 2,3,5,7 的倍数，当 n=10,结果只有 1 一个数。 #include&lt;iostream&gt; using namespace std; int main() { int n; cin&gt;&gt;n; int ans=n-(n/2+n/3+n/5+n/7)+(n/2/3+n/2/5+n/2/7+n/3/5+n/3/7+n/5/7)-(n/2/3/5+n/2/3/7+n/3/5/7+n/2/5/7)+n/2/3/5/7; //ans=n-(n/2+n/3+n/5+n/7)+(n/6+n/10+n/14+n/15+n/21+n/35)-(n/30+n/42+n/105+n/70)+n/210  cout&lt;&lt;ans&lt;&lt;endl; return 0; }  例子 2： 题目描述： V_Dr....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575440265389.html","articleImg1URL":"https://img.hacpai.com/file/2019/12/20190402164825432-bffcedb6.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"},{"articleTitle":"莫队算法 牛客多校赛题","articleAbstractText":"题目描述 Given a sequence of integers a 1 , a 2 , ..., a n and q pairs of integers (l 1 , r 1 ), (l 2 , r 2 ), ..., (l q , r q ), find count(l 1 , r 1 ), count(l 2 , r 2 ), ..., count(l q , r q ) where count(i, j) is the number of different integers among a 1 , a 2 , ..., a i , a j , a j + 1 , ..., a n . 输入描述： The input consists of several test cases and is terminated by end-of-file. The first line of each test cases contains two integers n and q. The second line contains n integers a 1 , a 2 , ...,....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575439848633.html","articleImg1URL":"https://img.hacpai.com/bing/20171129.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"素数判断","articleAbstractText":"bool is_prime(int u) { if (u == 0 || u == 1)return false; if (u == 2)return true; if (u % 2 == 0)return false; for (int i = 3; i &lt;= sqrt(u); i += 2) if (u%i == 0)return false; return true; }","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575440129024.html","articleImg1URL":"https://img.hacpai.com/bing/20190312.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"背包模板","articleAbstractText":"模板 /** * 多重背包： * 有N种物品和一个容量为 V的背包。第i种物品最多有 num[i]件可用， * 每件耗费的空间是C[i]，价值是W[i]。 * 求解将哪些物品装入背包可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。 */ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; #define maxn 100005 int c[maxn], w[maxn], num[maxn];//c:费用 w:价值 num:数量 int dp[maxn]; //当前位置符合题意的最优解 int V; //V:总容量  //01背包 void ZeroOnePack(int c, int w) { for (int v = V; v &gt;= c; v--) { dp[v] = max(dp[v], dp[v - c] + w); } } //完全背包 void CompletePack(int c, int w) { for (i....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575375623459.html","articleImg1URL":"https://img.hacpai.com/bing/20190928.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"邮票","articleAbstractText":"问题描述 　　给定一个信封，有 N（1≤ N≤100）个位置可以贴邮票，每个位置只能贴一张邮票。我们现在有 M(M&lt; =100)种不同邮资的邮票，面值为 X1,X2\u2026.Xm 分（Xi 是整数，1≤ Xi≤255），每种都有 N 张。 　　显然，信封上能贴的邮资最小值是 min(X1, X2, \u2026, Xm)，最大值是 N*max(X1, X2, \u2026,　　Xm)。由所有贴法得到的邮资值可形成一个集合（集合中没有重复数值），要求求出这个集合中是否存在从 1 到某个值的连续邮资序列，输出这个序列的 最大值。 　　例如，N=4，M=2，面值分别为 4 分，1 分，于是形成 1，2，3，4，5，6，7，8，9，10，12，13，16 的序列，而从 1 开始的连续邮资序列为 1，2，3，4，5，6，7，8，9，10，所以连续邮资序列的最大值为 10 分。 输入格式 　　第一行：最多允许粘贴的邮票张数 N；第二行：邮票种数 M；第三行：空格隔开的 M 个数字，表示邮票的面值 Xi。注意：Xi 序列不一定是大小有序的！ 输出格式 　　从 1 开始的连续邮资序列的最大值 MAX。若不存在从 1 分开....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575376583745.html","articleImg1URL":"https://img.hacpai.com/bing/20190309.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}