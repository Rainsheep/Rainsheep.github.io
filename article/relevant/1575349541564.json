{"relevantArticles":[{"articleTitle":"HUD-1060 Leftmost Digit","articleAbstractText":"题目链接：HDU\u20141060 对一个数 num 可写为 num=a10^n , 即科学计数法，使 a 的整数部分即为 num 的最高位数字 numnum=10n * a 这里的 n 与上面的 n 不等 两边取对数： numlg(num) = n + lg(a); 因为 a&lt;10，所以 0&lt;lg(a)&lt;1 令 x=n+lg(a); 则 n 为 x 的整数部分，lg(a)为 x 的小数部分 又 x=num*lg(num); a=10(x-n) = 10(x-int(x))) 再取 a 的整数部分即得 num 的最高位 总结：遇到大数无法处理的时候善于用 logn(x);log(x)表示以 e 为底，logn(x)表示自定义底数 #include&lt;iostream&gt; #include&lt;math.h&gt; using namespace std; int main() { int num,T,a; double n; cin&gt;&gt;T; while(T--) { cin&gt;&gt;num; n=num*log10(num);//num最大10位，....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575347380440.html","articleImg1URL":"https://img.hacpai.com/bing/20181220.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"莫队算法 牛客多校赛题","articleAbstractText":"题目描述 Given a sequence of integers a 1 , a 2 , ..., a n and q pairs of integers (l 1 , r 1 ), (l 2 , r 2 ), ..., (l q , r q ), find count(l 1 , r 1 ), count(l 2 , r 2 ), ..., count(l q , r q ) where count(i, j) is the number of different integers among a 1 , a 2 , ..., a i , a j , a j + 1 , ..., a n . 输入描述： The input consists of several test cases and is terminated by end-of-file. The first line of each test cases contains two integers n and q. The second line contains n integers a 1 , a 2 , ...,....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575439848633.html","articleImg1URL":"https://img.hacpai.com/bing/20171129.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"【C++】STL常用容器总结之五：双端队列deque","articleAbstractText":"6、双端队列 deque 所谓的 deque 是\u201ddouble ended queue\u201d的缩写，双端队列不论在尾部或头部插入元素，都十分迅速。而在中间插入元素则会比较费时，因为必须移动中间其他的元素。双端队列是一种随机访问的数据类型，提供了在序列两端快速插入和删除操作的功能，它可以在需要的时候改变自身大小，完成了标准的 C++ 数据结构中队列的所有功能。 Vector 是单向开口的连续线性空间，deque 则是一种双向开口的连续线性空间。deque 对象在队列的两端放置元素和删除元素是高效的，而向量 vector 只是在插入序列的末尾时操作才是高效的。deque 和 vector 的最大差异，一在于 deque 允许于常数时间内对头端进行元素的插入或移除操作，二在于 deque 没有所谓的 capacity 观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。换句话说，像 vector 那样\u201c因旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间\u201d这样的事情在 deque 中是不会发生的。也因此，deque 没有必要提供所谓的空间预留（reserve....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575382986055.html","articleImg1URL":"https://img.hacpai.com/bing/20190118.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"HDU-1005 Number Sequence 循环结","articleAbstractText":"一开始的思路是遇到 11 就开始循环，后来发现，发现当 A=5555，B=666666 时数列是 1142142142142，这种情况不是以 11 开始循环的，依然超时就罢了，关按 11 判断的话就错了。因为两个结果都一定是 0 到 6 之间的数，所以一定会循环，而且循环节不会超过 7*7=49。（因为前面 2 个数若相同，则第三个之后的数必相同，而在 49 内必能找到 2 个相邻的数在前面出现过）。 题目链接：HDU-1005 #include&lt;stdio.h&gt; int main() { int i,a,b,m,n,l,f[50]; while(~scanf(\"%d %d %d\",&amp;a,&amp;b,&amp;n)&amp;&amp;n) { f[1]=f[2]=1; if(n&lt;=2)f[n]=1; if(n&gt;2) { while(n&gt;49) { n=n-49; } for(i=3;i&lt;=n;i++) { f[i]=(a*f[i-1]+b*f[i-2])%7; } } printf(\"%d\\n\",f[n]); } return 0; }","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575347335905.html","articleImg1URL":"https://img.hacpai.com/bing/20190508.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"分解质因子","articleAbstractText":"任何一个合数可以分解为几个质数的乘积，这些质数也必然是这个合数的约数。 超时模板： #include&lt;bits/stdc++.h&gt; using namespace std; vector&lt;int&gt; fun(int n) { vector&lt;int&gt; v; for (int i = 2; i &lt;= n; i++) { while (n%i == 0) { n /= i; v.push_back(i); } } return v; } int main() { int n; cin &gt;&gt; n; vector&lt;int&gt; v = fun(n); for (auto it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } }  优化模板： #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;cmath&gt; using namespace std; vector&lt;int....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575440099127.html","articleImg1URL":"https://img.hacpai.com/bing/20180317.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}