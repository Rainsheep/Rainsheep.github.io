{"relevantArticles":[{"articleTitle":"hdu-2546 饭卡","articleAbstractText":"题目链接：hdu-2546 思路：DP[i][j]存的是 j 价格买 i 个物品最贵的价格，然后把二维变一维，第二层循环从后向前，依次覆盖上一层的 dp #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; int dp[1005];//dp存的J价格在0~i物品中可以购买到的最大价格 int main() { int money,i,j,k,m,n,s[1005],t,temp,end,maxt,sum; while(cin&gt;&gt;n,n) { memset(dp,0,sizeof(dp)); for(i=1;i&lt;=n;i++) { cin&gt;&gt;s[i]; } sort(s+1,s+1+n); cin&gt;&gt;money; if(money&lt;5)//小于5元，直接输出  { end=money; } else { money=money-5;//5元买最贵的  for(i=1;i&lt;=n-1;i++) { f....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575374076393.html","articleImg1URL":"https://img.hacpai.com/bing/20190522.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"素数判断","articleAbstractText":"bool is_prime(int u) { if (u == 0 || u == 1)return false; if (u == 2)return true; if (u % 2 == 0)return false; for (int i = 3; i &lt;= sqrt(u); i += 2) if (u%i == 0)return false; return true; }","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575440129024.html","articleImg1URL":"https://img.hacpai.com/bing/20190312.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"LIS（最长上升子序列）","articleAbstractText":"方法一： dp 动态规划 状态设计：dp[i]代表以 a[i]结尾的 LIS 的长度 状态转移：dp[i]=max(dp[i], dp[j]+1) (0&lt;=j&lt; i, a[j]&lt; a[i]) 时间复杂度：O(N^2) 例题：https://blog.csdn.net/y201619819/article/details/78354348 方法二：贪心 + 二分 时间复杂度 Nlog(N) a[i]表示第 i 个数据。 dp[i]表示表示长度为 i+1 的 LIS 结尾元素的最小值。 利用贪心的思想，对于一个上升子序列，显然当前最后一个元素越小，越有利于添加新的元素，这样 LIS 长度自然更长。 因此，我们只需要维护 dp 数组，其表示的就是长度为 i+1 的 LIS 结尾元素的最小值，保证每一位都是最小值，这样子 dp 数组的长度就是 LIS 的长度。 dp 数组具体维护过程同样举例讲解更为清晰。 同样对于序列 a(1, 7, 3, 5, 9, 4, 8)，dp 的变化过程如下： dp[0] = a[0] = 1，长度为 1 的 LIS 结尾元素的最小值自然没得挑，就....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575436974755.html","articleImg1URL":"https://img.hacpai.com/bing/20180917.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"邮票","articleAbstractText":"问题描述 　　给定一个信封，有 N（1≤ N≤100）个位置可以贴邮票，每个位置只能贴一张邮票。我们现在有 M(M&lt; =100)种不同邮资的邮票，面值为 X1,X2\u2026.Xm 分（Xi 是整数，1≤ Xi≤255），每种都有 N 张。 　　显然，信封上能贴的邮资最小值是 min(X1, X2, \u2026, Xm)，最大值是 N*max(X1, X2, \u2026,　　Xm)。由所有贴法得到的邮资值可形成一个集合（集合中没有重复数值），要求求出这个集合中是否存在从 1 到某个值的连续邮资序列，输出这个序列的 最大值。 　　例如，N=4，M=2，面值分别为 4 分，1 分，于是形成 1，2，3，4，5，6，7，8，9，10，12，13，16 的序列，而从 1 开始的连续邮资序列为 1，2，3，4，5，6，7，8，9，10，所以连续邮资序列的最大值为 10 分。 输入格式 　　第一行：最多允许粘贴的邮票张数 N；第二行：邮票种数 M；第三行：空格隔开的 M 个数字，表示邮票的面值 Xi。注意：Xi 序列不一定是大小有序的！ 输出格式 　　从 1 开始的连续邮资序列的最大值 MAX。若不存在从 1 分开....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575376583745.html","articleImg1URL":"https://img.hacpai.com/bing/20190309.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"拦截导弹（规律：下降子序列的个数等于最长上升子序列的长度）","articleAbstractText":"问题描述 　　某国为了防御敌国的导弹袭击，发展出一种导弹 拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的 导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。 　　输入导弹依次飞来的高度（雷达给出的高度数据是不大于 30000 的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入格式 　　一行，为导弹依次飞来的高度 输出格式 　　两行，分别是最多能拦截的导弹数与要拦截所有导弹最少要配备的系统数 样例输入 389 207 155 300 299 170 158 65 样例输出 6 2 规律：下降子序列的个数等于最长上升子序列的长度 #include &lt;iostream&gt;  using namespace std; int main() { int a[1005]; int d[1005]; int i=1; while(cin&gt;&gt;a[i]) { i++; } int n=i; int ma....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575376746513.html","articleImg1URL":"https://img.hacpai.com/bing/20190207.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}