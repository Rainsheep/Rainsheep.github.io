{"relevantArticles":[{"articleTitle":"SpringMVC 学习笔记","articleAbstractText":"1. SpringMVC 基础   SpringMVC 在 在 三层架构的位置   SpringMVC 的优势  清晰的角色划分：  前端控制器（DispatcherServlet） 请求到处理器映射（HandlerMapping） 处理器适配器（HandlerAdapter） 视图解析器（ViewResolver） 处理器或页面控制器（Controller） 验证器（ Validator） 命令对象（Command 请求参数绑定到的对象就叫命令对象） 表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）。   分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要。 由于命令对象就是一个 POJO，无需继承框架特定 API，可以使用命令对象直接作为业务对象。 和 Spring 其他框架无缝集成，是其它 Web 框架所不具备的。 可适配，通过 HandlerAdapter 可以支持任意的类作为处理器。 可定制性，HandlerMapping、ViewResolver 等能够非常简单的定制。 功能强大的数据验证、格式化、绑定机制。 利用 Spring 提供的....","articleStatus":0,"articlePermalink":"/articles/2020/03/10/1583771477763.html","articleImg1URL":"https://raw.githubusercontent.com/Rainsheep/pic-bed/master/img/2020-03-04+13:26:52+01%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.png?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"Spring 学习笔记","articleAbstractText":"1. Spring 框架了解  Spring 是分层的 Java SE/EE 应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的 Java EE 企业应用开源框架。 Spring 的优势  方便解耦，简化开发 通过 Spring 提供的 IoC 容器，可以将对象间的依赖关系交由 Spring 进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。 AOP 编程的支持 通过 Spring 的 AOP 功能，方便进行面向切面的编程，许多不容易用传统 OOP 实现的功能可以通过 AOP 轻松应付。 声明式事务的支持 可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开....","articleStatus":0,"articlePermalink":"/articles/2020/03/08/1583653357274.html","articleImg1URL":"https://raw.githubusercontent.com/Rainsheep/pic-bed/master/img/2020-03-06+15:46:26+spring-overview.png?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"ssm 整合","articleAbstractText":"1. 搭建整合环境  采用 XML+ 注解的方式进行整合 整合思路：  先搭建整合环境 再把 Spring 配置搭建完成 再使用 Spring 整合 SpringMVC 框架 最后使用 Spring 整合 MyBatis 框架   创建数据库和表结构 create database ssm; use ssm; create table account( id int primary key auto_increment, name varchar(20), money double );   Maven 坐标 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4....","articleStatus":0,"articlePermalink":"/articles/2020/03/11/1583867371280.html","articleImg1URL":"https://raw.githubusercontent.com/Rainsheep/pic-bed/master/img/2020-03-11+01:06:38+02.bmp?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"八皇后","articleAbstractText":"八皇后问题是一个以国际象棋为背景的问题：如何能够在 8×8 的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。 #include&lt;stdio.h&gt; #define N 8 int queen[N+1],flag[N+1]={0},s1[2*N+1]={0},s2[2*N+1]={0}; /*queue[i]存第i行的皇后在哪一列，flag[i]存第i列是否有皇后，s1存每个左上和右下所在的这个斜线有没有皇后，i行j列 所在元素的斜线即为s1[i+j]，同理，s2存右上，左下，为s2[i-j+N]*/ int n=0;//记录方案数 void print() { printf(\"\\n方案%d:\\n\",++n); for(int i=1;i&lt;=N;i++) { for(int j=1;j&lt;=N;j++) { if(queen[i]==j)printf(\"Q \");//此行的皇后在此列  else printf(\"* \"); } printf(\"\\n\"); } } void fun(i....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575376500989.html","articleImg1URL":"https://img.hacpai.com/bing/20190506.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"Java 格式化显示金额","articleAbstractText":"DecimalFormat decimalFormat = new DecimalFormat(\"###,###.00\"); System.out.println(decimalFormat.format(1002200999.22323)); //1,002,200,999.22","articleStatus":0,"articlePermalink":"/articles/2020/03/31/1585591249751.html","articleImg1URL":"https://img.hacpai.com/bing/20180416.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}