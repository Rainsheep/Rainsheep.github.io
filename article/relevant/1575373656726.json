{"relevantArticles":[{"articleTitle":"莫队算法 牛客多校赛题","articleAbstractText":"题目描述 Given a sequence of integers a 1 , a 2 , ..., a n and q pairs of integers (l 1 , r 1 ), (l 2 , r 2 ), ..., (l q , r q ), find count(l 1 , r 1 ), count(l 2 , r 2 ), ..., count(l q , r q ) where count(i, j) is the number of different integers among a 1 , a 2 , ..., a i , a j , a j + 1 , ..., a n . 输入描述： The input consists of several test cases and is terminated by end-of-file. The first line of each test cases contains two integers n and q. The second line contains n integers a 1 , a 2 , ...,....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575439848633.html","articleImg1URL":"https://img.hacpai.com/bing/20171129.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"容斥定理","articleAbstractText":"要计算几个集合并集的大小，我们要先将所有单个集合的大小计算出来，然后减去所有两个集合相交的部分，再加回所有三个集合相交的部分，再减去所有四个集合相交的部分，依此类推，一直计算到所有集合相交的部分。 简单来说，就是奇加偶减。  举个例子： 求 1~n 中多少个数不是 2,3,5,7 的倍数，当 n=10,结果只有 1 一个数。 #include&lt;iostream&gt; using namespace std; int main() { int n; cin&gt;&gt;n; int ans=n-(n/2+n/3+n/5+n/7)+(n/2/3+n/2/5+n/2/7+n/3/5+n/3/7+n/5/7)-(n/2/3/5+n/2/3/7+n/3/5/7+n/2/5/7)+n/2/3/5/7; //ans=n-(n/2+n/3+n/5+n/7)+(n/6+n/10+n/14+n/15+n/21+n/35)-(n/30+n/42+n/105+n/70)+n/210  cout&lt;&lt;ans&lt;&lt;endl; return 0; }  例子 2： 题目描述： V_Dr....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575440265389.html","articleImg1URL":"https://img.hacpai.com/file/2019/12/20190402164825432-bffcedb6.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"},{"articleTitle":"LIS（最长上升子序列）","articleAbstractText":"方法一： dp 动态规划 状态设计：dp[i]代表以 a[i]结尾的 LIS 的长度 状态转移：dp[i]=max(dp[i], dp[j]+1) (0&lt;=j&lt; i, a[j]&lt; a[i]) 时间复杂度：O(N^2) 例题：https://blog.csdn.net/y201619819/article/details/78354348 方法二：贪心 + 二分 时间复杂度 Nlog(N) a[i]表示第 i 个数据。 dp[i]表示表示长度为 i+1 的 LIS 结尾元素的最小值。 利用贪心的思想，对于一个上升子序列，显然当前最后一个元素越小，越有利于添加新的元素，这样 LIS 长度自然更长。 因此，我们只需要维护 dp 数组，其表示的就是长度为 i+1 的 LIS 结尾元素的最小值，保证每一位都是最小值，这样子 dp 数组的长度就是 LIS 的长度。 dp 数组具体维护过程同样举例讲解更为清晰。 同样对于序列 a(1, 7, 3, 5, 9, 4, 8)，dp 的变化过程如下： dp[0] = a[0] = 1，长度为 1 的 LIS 结尾元素的最小值自然没得挑，就....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575436974755.html","articleImg1URL":"https://img.hacpai.com/bing/20180917.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"矩形的交面积","articleAbstractText":"矩形边平行 X 轴或 Y 轴 输入：矩形某对角线上两个点 输出：交面积 #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; int main() { double x1,y1,x2,y2; double x3,y3,x4,y4; double m1,m2,n1,n2; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;x3&gt;&gt;y3&gt;&gt;x4&gt;&gt;y4; m1=min(max(x1,x2),max(x3,x4)); n1=min(max(y1,y2),max(y3,y4)); m2=max(min(x1,x2),min(x3,x4)); n2=max(min(y1,y2),min(y3,y4)); if(m1&gt;m2&amp;&amp;n1&gt;n2) { cout&lt;&lt;(m1-m2)*(n1-n2)&lt;&lt;endl; } else cout&lt;&lt;\"0.00\"&lt;&lt;endl; r....","articleStatus":0,"articlePermalink":"/articles/2019/12/04/1575440043701.html","articleImg1URL":"https://img.hacpai.com/bing/20190211.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"拦截导弹（规律：下降子序列的个数等于最长上升子序列的长度）","articleAbstractText":"问题描述 　　某国为了防御敌国的导弹袭击，发展出一种导弹 拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的 导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。 　　输入导弹依次飞来的高度（雷达给出的高度数据是不大于 30000 的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入格式 　　一行，为导弹依次飞来的高度 输出格式 　　两行，分别是最多能拦截的导弹数与要拦截所有导弹最少要配备的系统数 样例输入 389 207 155 300 299 170 158 65 样例输出 6 2 规律：下降子序列的个数等于最长上升子序列的长度 #include &lt;iostream&gt;  using namespace std; int main() { int a[1005]; int d[1005]; int i=1; while(cin&gt;&gt;a[i]) { i++; } int n=i; int ma....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575376746513.html","articleImg1URL":"https://img.hacpai.com/bing/20190207.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}