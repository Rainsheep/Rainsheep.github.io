{"randomArticles":[{"articleTitle":"solo导出静态站点","articleAbstractText":"docker cp solo:/opt/solo/static-site ~/static-site","articleStatus":0,"articlePermalink":"/articles/2020/07/29/1596030733146.html","articleImg1URL":"https://b3logfile.com/bing/20171109.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"Windows10右键添加\u201c在此处打开命令窗口\u201d","articleAbstractText":"效果 第一个是在 桌面 / 文件夹窗口中 / 选中文件夹上 直接点击右键，显示\u201c在此处打开命令窗口\u201d选项，如图：  第二个是在 桌面 / 文件夹窗口中 / 选中文件夹上 按住 Shift 键点击右键，同时显示\u201c在此处打开命令窗口\u201d和\u201c在此处打开 Powershell 窗口\u201d两个选项，如图：  具体步骤 第一步：新建一个 txt 文件，命名为 OpenCmdHere.txt 第二步：在文件中输入如下代码，并保存 Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\Directory\\shell\\OpenCmdHere] @=\"在此处打开命令窗口\" \"Icon\"=\"cmd.exe\" [HKEY_CLASSES_ROOT\\Directory\\shell\\OpenCmdHere\\command] @=\"cmd.exe /s /k pushd \"%V\"\" [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCmdHere] @=\"在此处打开命令窗口\" \"Icon\"=\"cmd.exe\" [H....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575342092041.html","articleImg1URL":"https://img.hacpai.com/file/2019/12/20171216201806453-91962cae.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"},{"articleTitle":"毕业论文","articleAbstractText":"201619819 杨珑奇基于 SSM 框架的学生社团活动管理系统设计与实现.zip","articleStatus":0,"articlePermalink":"/articles/2020/07/29/1596030101076.html","articleImg1URL":"https://b3logfile.com/bing/20190706.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"重载运算符","articleAbstractText":"#include&lt;iostream&gt; using namespace std; struct node { int a,b; node(int x,int y):a(x),b(y){//构造函数  } int operator ^ (const node &amp;x){//重载运算符 ，一个参数  return x.a*b+x.b*a; } } ; int main() { node a(1,2),b(2,3); cout&lt;&lt;a.operator ^(b)&lt;&lt;endl; printf(\"%d\\n\",a^b); cout&lt;&lt;(a^b)&lt;&lt;endl;//不加括号不行  }","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575376162797.html","articleImg1URL":"https://img.hacpai.com/bing/20181028.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"hdu-2151 Worm","articleAbstractText":"题目链接：hdu-2151 思路：dp[i][j]表示 i 分钟时到达 j 树的方案数，此方案数等于上一层相邻的两个的方案数综合，dp 公式 dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]; #include&lt;iostream&gt; using namespace std; int main() { int dp[105][105], i, j, k, l, m, n,p,t;//dp[i][j]表示i分钟时到达j树的方案数  while (cin &gt;&gt; n &gt;&gt; p &gt;&gt; m &gt;&gt; t) { for (i = 0; i &lt;= m; i++) for (j = 0; j &lt;= n+1; j++) { dp[i][j] = 0;//在最左边和最右边都多加一列，初始化为0，好利用公式，不需要在判断  } dp[0][p] = 1;//初始点的方案数初始化为1  for(i=1;i&lt;=m;i++) for (j = 1; j &lt;= n; j++) { dp[i][j]....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575374027915.html","articleImg1URL":"https://img.hacpai.com/bing/20191113.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}