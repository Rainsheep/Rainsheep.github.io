{"randomArticles":[{"articleTitle":"最大子阵","articleAbstractText":"题目描述 给定一个 n× m 的矩阵 A，求 A 中的一个非空子矩阵，使这个子矩阵中的元素和最大。其中，A 的子矩阵指在 A 中行和列均连续的一部分。 输入格式 输入的第一行包含两个整数 n,m(1 &lt;= n,m &lt;= 50)n,m(1≤ n,m≤50)，分别表示矩阵 A 的行数和列数。接下来 n 行，每行 m 个整数，表示矩阵 A_{i,j}(-1000 &lt;=A_{i,j} &lt;= 1000),A i,j (−1000≤ A i,j≤1000)。 输出格式 输出一行，包含一个整数，表示 AA 中最大的子矩阵中的元素和。 样例输入 3 3 2 -4 1 -1 2 1 4 -2 2 样例输出 6 /*循环每一行作为开始，b[i]为到达此行时每列的和,maxc函数求出最大连续列，类似于dp*/ #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;map&gt; #include&lt;set&gt; #inc....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575377023275.html","articleImg1URL":"https://img.hacpai.com/bing/20180406.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"Servlet 学习笔记","articleAbstractText":"1. Servlet 基础知识   概念：server applet，运行在服务器端的小程序。  Servlet 就是一个接口，定义了 Java 类被浏览器访问到 (tomcat 识别) 的规则。 将来我们自定义一个类，实现 Servlet 接口，复写方法。     执行原理：  当服务器接受到客户端浏览器的请求后，会解析请求 URL 路径，获取访问的 Servlet 的资源路径 查找 web.xml 文件，是否有对应的 &lt;url-pattern&gt; 标签体内容。 如果有，则在找到对应的 &lt;servlet-class&gt; 全类名。 tomca t 会将字节码文件加载进内存，并且创建其对象。 调用其方法。     快速入门： //web.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schema....","articleStatus":0,"articlePermalink":"/articles/2020/02/24/1582545439417.html","articleImg1URL":"https://raw.githubusercontent.com/Rainsheep/pic-bed/master/img/2020-02-24+14:47:47+Servlet.bmp?imageView2/2/w/1280/format/jpg/interlace/1/q/100"},{"articleTitle":"毕业论文","articleAbstractText":"201619819 杨珑奇基于 SSM 框架的学生社团活动管理系统设计与实现.zip","articleStatus":0,"articlePermalink":"/articles/2020/07/29/1596030101076.html","articleImg1URL":"https://b3logfile.com/bing/20190706.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"计算几何","articleAbstractText":"点击跳转","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575376239169.html","articleImg1URL":"https://img.hacpai.com/bing/20180504.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"hdu-2151 Worm","articleAbstractText":"题目链接：hdu-2151 思路：dp[i][j]表示 i 分钟时到达 j 树的方案数，此方案数等于上一层相邻的两个的方案数综合，dp 公式 dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]; #include&lt;iostream&gt; using namespace std; int main() { int dp[105][105], i, j, k, l, m, n,p,t;//dp[i][j]表示i分钟时到达j树的方案数  while (cin &gt;&gt; n &gt;&gt; p &gt;&gt; m &gt;&gt; t) { for (i = 0; i &lt;= m; i++) for (j = 0; j &lt;= n+1; j++) { dp[i][j] = 0;//在最左边和最右边都多加一列，初始化为0，好利用公式，不需要在判断  } dp[0][p] = 1;//初始点的方案数初始化为1  for(i=1;i&lt;=m;i++) for (j = 1; j &lt;= n; j++) { dp[i][j]....","articleStatus":0,"articlePermalink":"/articles/2019/12/03/1575374027915.html","articleImg1URL":"https://img.hacpai.com/bing/20191113.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}